/// <reference lib="webworker" />
export {};

declare const self: ServiceWorkerGlobalScope;

// Vite will replace BASE_URL at build time. Keep everything base-aware for GH Pages.
const BASE = normalizeBase((import.meta as any).env?.BASE_URL || "/"); // "/" or "/repo-name/"
const VITE_PREFIX = join(BASE, "vite/");                               // "/vite/" or "/repo-name/vite/"
const CHANNEL_NAME = `${VITE_PREFIX}bus`;
const CACHE_NAME = `${VITE_PREFIX}cache-v1`;

function normalizeBase(b: string) {
  return (b.endsWith("/") ? b : b + "/").replace(/\/+/g, "/");
}
function join(a: string, b: string) {
  return normalizeBase(a.replace(/\/+$/, "/") + b.replace(/^\/+/, ""));
}

self.addEventListener("install", (event) => {
  event.waitUntil(self.skipWaiting());
});

self.addEventListener("activate", (event) => {
  event.waitUntil(self.clients.claim());
});

const bc = new BroadcastChannel(CHANNEL_NAME);

// Correlate compile requests <-> responses
type Resolver = (value: Response) => void;
const pending = new Map<string, Resolver>();

bc.addEventListener("message", (evt) => {
  const msg = evt.data || {};
  if (msg.type === "COMPILE_RESPONSE") {
    const { id, ok, status = ok ? 200 : 500, body = "", headers = {} } = msg;
    const res = new Response(ok ? body : "Not Found", { status, headers });
    const resolve = pending.get(id);
    if (resolve) {
      pending.delete(id);
      resolve(res);
    }
  }
});

function uuid() {
  // A tiny uuid-ish for correlation
  return Math.random().toString(36).slice(2) + Date.now().toString(36);
}

async function compileThroughWorker(urlPath: string, request: Request): Promise<Response> {
  const id = uuid();
  const p = new Promise<Response>((resolve) => pending.set(id, resolve));
  bc.postMessage({ type: "COMPILE_REQUEST", id, url: urlPath });
  const res = await p;

  // Cache successful results
  if (res.ok) {
    const cache = await caches.open(CACHE_NAME);
    await cache.put(request, res.clone());
  }
  return res;
}

// Small helper for preview index resolution
function normalizePreviewPath(pathname: string) {
  if (pathname.endsWith("/preview/")) return pathname + "index.html";
  return pathname;
}

// HTML response for the exact /<base>vite/ path
function landingHtml(): Response {
  const html = `<!doctype html>
<html>
  <head><meta charset="utf-8"><title>Vite Sandbox SW</title></head>
  <body>
    <h1>Service Worker landing</h1>
    <p>You requested <code>${VITE_PREFIX}</code>. This page is generated by the Service Worker.</p>
    <p>Open <a href="${join(VITE_PREFIX, "preview/")}">${join(VITE_PREFIX, "preview/")}</a> to see the preview.</p>
  </body>
</html>`;
  return new Response(html, { headers: { "Content-Type": "text/html; charset=utf-8" } });
}

// Main router
self.addEventListener("fetch", (event: FetchEvent) => {
  const url = new URL(event.request.url);

  // Only handle requests within our scoped path
  if (!url.pathname.startsWith(VITE_PREFIX)) return;

  // Exact landing page
  if (url.pathname === VITE_PREFIX && event.request.method === "GET") {
    event.respondWith(landingHtml());
    return;
  }

  // Handle preview assets via the worker "compiler"
  if (url.pathname.startsWith(join(VITE_PREFIX, "preview/")) && event.request.method === "GET") {
    event.respondWith((async () => {
      const cache = await caches.open(CACHE_NAME);
      // Normalize "/preview/" -> "/preview/index.html" for cache key, but keep original Request as the key
      const normalizedPath = normalizePreviewPath(url.pathname);
      const cached = await cache.match(event.request);
      if (cached) return cached;

      // Ask the worker for a compiled asset (string body + headers)
      // We pass the normalized path to the worker VFS, but cache under the original request.
      return compileThroughWorker(normalizedPath, event.request);
    })());
    return;
  }

  // Passthrough everything else under /vite/
  event.respondWith(fetch(event.request));
});

// Simple postMessage ping/pong for the page
self.addEventListener("message", (event: ExtendableMessageEvent) => {
  const data = event.data;
  if (data?.type === "PING_FROM_PAGE") {
    (event.source as Client | null)?.postMessage({ type: "PONG_FROM_SW", at: Date.now() });
  }
});
