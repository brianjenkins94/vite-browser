/// <reference lib="webworker" />
export {};

declare const self: ServiceWorkerGlobalScope;

const BASE = norm((import.meta as any).env?.BASE_URL || "/");
const VITE_PREFIX = join(BASE, "vite/");
const CHANNEL_NAME = `${VITE_PREFIX}bus`;
const CACHE_NAME = `${VITE_PREFIX}cache-v1`;

function norm(p: string) {
  return (p.endsWith("/") ? p : p + "/").replace(/\/+/g, "/");
}
function join(a: string, b: string) {
  return norm(a.replace(/\/+$/, "/") + b.replace(/^\/+/, ""));
}

self.addEventListener("install", (e) => e.waitUntil(self.skipWaiting()));
self.addEventListener("activate", (e) => e.waitUntil(self.clients.claim()));

const bc = new BroadcastChannel(CHANNEL_NAME);

// correlate COMPILE_REQUEST/RESPONSE
const pending = new Map<string, (r: Response) => void>();
function uid() {
  return Math.random().toString(36).slice(2) + Date.now().toString(36);
}
bc.addEventListener("message", (evt) => {
  const m = evt.data || {};
  if (m.type === "COMPILE_RESPONSE") {
    const { id, ok, status = ok ? 200 : 500, body = "", headers = {} } = m;
    const res = new Response(ok ? body : "Not Found", { status, headers });
    const resolve = pending.get(id);
    if (resolve) {
      pending.delete(id);
      resolve(res);
    }
  }
});

async function viaWorker(urlPath: string, req: Request) {
  const id = uid();
  const p = new Promise<Response>((resolve) => pending.set(id, resolve));
  bc.postMessage({ type: "COMPILE_REQUEST", id, url: urlPath });
  const res = await p;
  if (res.ok) {
    const cache = await caches.open(CACHE_NAME);
    await cache.put(req, res.clone());
  }
  return res;
}

function landing(): Response {
  const html = `<!doctype html>
<html><head><meta charset="utf-8"><title>Vite Sandbox SW</title></head>
<body>
  <h1>Service Worker landing</h1>
  <p>You requested <code>${VITE_PREFIX}</code>. This HTML is generated by the SW.</p>
  <p>Open <a href="${join(VITE_PREFIX, "preview/")}">${join(
    VITE_PREFIX,
    "preview/"
  )}</a> to see the preview.</p>
</body></html>`;
  return new Response(html, {
    headers: { "Content-Type": "text/html; charset=utf-8" },
  });
}

self.addEventListener("fetch", (event: FetchEvent) => {
  const url = new URL(event.request.url);

  if (!url.pathname.startsWith(VITE_PREFIX)) return;

  // exact /<base>/vite/
  if (url.pathname === VITE_PREFIX && event.request.method === "GET") {
    event.respondWith(landing());
    return;
  }

  // /<base>/vite/preview/**
  if (
    url.pathname.startsWith(join(VITE_PREFIX, "preview/")) &&
    event.request.method === "GET"
  ) {
    event.respondWith(
      (async () => {
        const cache = await caches.open(CACHE_NAME);
        const hit = await cache.match(event.request);
        if (hit) return hit;
        const normalized =
          url.pathname.endsWith("/preview/") ? url.pathname + "index.html" : url.pathname;
        return viaWorker(normalized, event.request);
      })()
    );
    return;
  }

  // passthrough under /vite/ for anything else
  event.respondWith(fetch(event.request));
});

// postMessage ping/pong
self.addEventListener("message", (event: ExtendableMessageEvent) => {
  if (event.data?.type === "PING_FROM_PAGE") {
    (event.source as Client | null)?.postMessage({
      type: "PONG_FROM_SW",
      at: Date.now(),
    });
  }
});
