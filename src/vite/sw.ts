/// <reference lib="webworker" />
export {};

import { clientsClaim } from 'workbox-core';
clientsClaim();

declare const self: ServiceWorkerGlobalScope;

// --- path utils (dir keeps trailing slash; file paths do NOT) ---
function dir(p: string) {
  const s = ('/' + p).replace(/\/+/g, '/');
  return s.endsWith('/') ? s : s + '/';
}
function pathJoin(...segs: string[]) {
  return ('/' + segs.map(s => s.replace(/^\/+|\/+$/g, '')).filter(Boolean).join('/')).replace(/\/+/g, '/');
}

const BASE        = dir((import.meta as any).env?.BASE_URL || '/'); // "/" or "/repo-name/"
const VITE_PREFIX = dir(pathJoin(BASE, 'vite'));                    // "/vite/" or "/repo-name/vite/"
const CHANNEL_NAME = `${VITE_PREFIX}bus`;

self.addEventListener('install', e => e.waitUntil(self.skipWaiting()));
self.addEventListener('activate', e => e.waitUntil(self.clients.claim()));

// ---- Bridge to bundler worker ----
const bc = new BroadcastChannel(CHANNEL_NAME);
const pending = new Map<string, (r: Response) => void>();

bc.addEventListener('message', (evt) => {
  const m = evt.data || {};
  if (m.type === 'COMPILE_RESPONSE') {
    const { id, ok, status = ok ? 200 : 500, body = '', headers = {} } = m;
    const res = new Response(ok ? body : 'Not Found', { status, headers });
    const resolve = pending.get(id);
    if (resolve) { pending.delete(id); resolve(res); }
  }
});

function uid() { return Math.random().toString(36).slice(2) + Date.now().toString(36); }

async function viaWorker(urlPath: string): Promise<Response> {
  const id = uid();
  const waitP = new Promise<Response>(resolve => pending.set(id, resolve));
  bc.postMessage({ type: 'COMPILE_REQUEST', id, url: urlPath });

  // 2.5s timeout -> return HTML so you can see details in the iframe
  const timeoutP = new Promise<Response>(resolve =>
    setTimeout(() => resolve(new Response(
      `<!doctype html><meta charset="utf-8"><title>SW timeout</title>
       <pre>SW timed out waiting for worker\nkey: ${urlPath}</pre>`,
      { status: 504, headers: { 'Content-Type': 'text/html; charset=utf-8' } }
    )), 2500)
  );
  return Promise.race([waitP, timeoutP]);
}

// SW landing page for exact /<base>/vite/
function landing(): Response {
  const html = `<!doctype html>
<html><head><meta charset="utf-8"><title>Vite Sandbox SW</title></head>
<body>
  <h1>Service Worker landing</h1>
  <p>This page is generated by the SW at <code>${VITE_PREFIX}</code>.</p>
  <p>Open <a href="${pathJoin(VITE_PREFIX, 'preview/')}">${pathJoin(VITE_PREFIX, 'preview/')}</a> to see the preview.</p>
</body></html>`;
  return new Response(html, { headers: { 'Content-Type': 'text/html; charset=utf-8' } });
}

self.addEventListener('fetch', (event: FetchEvent) => {
  const url = new URL(event.request.url);

  if (!url.pathname.startsWith(VITE_PREFIX)) return;

  if (url.pathname === VITE_PREFIX && event.request.method === 'GET') {
    event.respondWith(landing()); return;
  }

  if (url.pathname.startsWith(pathJoin(VITE_PREFIX, 'preview/')) && event.request.method === 'GET') {
    event.respondWith((async () => {
      const normalized = url.pathname.endsWith('/preview/')
        ? pathJoin(url.pathname, 'index.html') // <-- no trailing slash
        : url.pathname;
      return viaWorker(normalized);
    })());
    return;
  }

  event.respondWith(fetch(event.request));
});

// Ping/pong
self.addEventListener('message', (event: ExtendableMessageEvent) => {
  if (event.data?.type === 'PING_FROM_PAGE') {
    (event.source as Client | null)?.postMessage({ type: 'PONG_FROM_SW', at: Date.now() });
  }
});
